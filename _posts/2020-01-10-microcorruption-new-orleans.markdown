---
layout: post
title:  "Microcorruption: New Orleans"
date:   2020-01-10 14:16:53
categories: reverse-engineering ctf
tags: reverse-engineering ctf microcorruption
series: Microcorruption
excerpt: This is the first level after completing the tutorial. You'll want to complete that before starting here as none of the debugging commands or GUI components will be explained.
mathjax: false
---

Let's start by searching for the **main** function within Disassembly.

```
4438 <main>
4438:  3150 9cff      add	#0xff9c, sp
443c:  b012 7e44      call	#0x447e <create_password>
4440:  3f40 e444      mov	#0x44e4 "Enter the password to continue", r15
4444:  b012 9445      call	#0x4594 <puts>
4448:  0f41           mov	sp, r15
444a:  b012 b244      call	#0x44b2 <get_password>
444e:  0f41           mov	sp, r15
4450:  b012 bc44      call	#0x44bc <check_password>
4454:  0f93           tst	r15
4456:  0520           jnz	#0x4462 <main+0x2a>
4458:  3f40 0345      mov	#0x4503 "Invalid password; try again.", r15
445c:  b012 9445      call	#0x4594 <puts>
4460:  063c           jmp	#0x446e <main+0x36>
4462:  3f40 2045      mov	#0x4520 "Access Granted!", r15
4466:  b012 9445      call	#0x4594 <puts>
446a:  b012 d644      call	#0x44d6 <unlock_door>
446e:  0f43           clr	r15
4470:  3150 6400      add	#0x64, sp
```

Three password-related functions are being called: **create_password**, **get_password**, and **check_password**.

Letâ€™s start with the **create_password** function:

```
447e <create_password>
447e:  3f40 0024      mov	#0x2400, r15
4482:  ff40 6300 0000 mov.b	#0x63, 0x0(r15)
4488:  ff40 3c00 0100 mov.b	#0x3c, 0x1(r15)
448e:  ff40 6900 0200 mov.b	#0x69, 0x2(r15)
4494:  ff40 3d00 0300 mov.b	#0x3d, 0x3(r15)
449a:  ff40 6200 0400 mov.b	#0x62, 0x4(r15)
44a0:  ff40 4b00 0500 mov.b	#0x4b, 0x5(r15)
44a6:  ff40 5800 0600 mov.b	#0x58, 0x6(r15)
44ac:  cf43 0700      mov.b	#0x0, 0x7(r15)
44b0:  3041           ret
```

Here we see the string **c<i=bKX** being built from hex and stored at the address **2400**.

Let's look at **get_password** and **getsn**:

```
44b2 <get_password>
44b2:  3e40 6400      mov	#0x64, r14
44b6:  b012 8445      call	#0x4584 <getsn>
44ba:  3041           ret
...
4584 <getsn>
4584:  0e12           push	r14
4586:  0f12           push	r15
4588:  2312           push	#0x2
458a:  b012 3045      call	#0x4530 <INT>
458e:  3150 0600      add	#0x6, sp
4592:  3041           ret
```

It's difficult to tell what's happening here by looking at just the assembly. The **get_password** function puts **0x64** into **r14** for an unknown reason and then calls **getsn**. The **getsn** pushes 3 registers onto the stack and calls **INT**. This appears similar to a Linux Syscall, but I was unable to find any information confirming that this is the case.  

After **INT** is called, the GUI appears and we're prompted to enter a password. After we enter a password, we see it stored at **439c**.  The return from both **getsn** and **get_password** sets the stack pointer to **439c**. This address is stored in **r15** before calling **check_password**.

Let's look at **check_password**:

```
44bc <check_password>
44bc:  0e43           clr	r14
44be:  0d4f           mov	r15, r13
44c0:  0d5e           add	r14, r13
44c2:  ee9d 0024      cmp.b	@r13, 0x2400(r14)
44c6:  0520           jne	#0x44d2 <check_password+0x16>
44c8:  1e53           inc	r14
44ca:  3e92           cmp	#0x8, r14
44cc:  f823           jne	#0x44be <check_password+0x2>
44ce:  1f43           mov	#0x1, r15
44d0:  3041           ret
44d2:  0f43           clr	r15
44d4:  3041           ret
```

Here we see **r14** is cleared, and our input at **r15** is mov'd to **r13**. The value in **r14** is added to and stored in **r13**. A byte is compared from **r13** and whatever is at address **0x2400** and indexed by **r14**.  The data at address **2400** was set by the **create_password** function. 

The **check_password** function compares our input to the string generated by **create_password**. 

Looking a little further down, we can see this is a loop with **r14** serving as the counter. The loop will continue until **r14** equals 8.  This means our password must be 8 characters long, which the string at **0x2400** is when you include the null terminator.

Reset the device and enter **solve** into the debugger. When prompted, enter **c<i=bKX** as your password. Make sure the hex input checkbox is unchecked, and press **send**. The door should now be unlocked.